HEX

3F200034 CONSTANT GPLEV0
3F200008 CONSTANT GPSEL2

\ GPIO 17
11 CONSTANT BUTTON_OFF
\ GPIO 16
10 CONSTANT BUTTON_RESET
\ GPIO 22
16 CONSTANT BUTTON_RIGHT
\ GPIO 23
17 CONSTANT BUTTON_DOWN
\ GPIO 24
18 CONSTANT BUTTON_UP
\ GPIO 27
1B CONSTANT BUTTON_LEFT


VARIABLE START_POINT
VARIABLE START_CHECK
VARIABLE STOP_CHECK

\ dato il numero della porta GPIO restiuiamo la maschera corretta
\ ( button_gpio -- gpio_mask)
: GPIO_MASK 1 SWAP LSHIFT ;

\ ( microseconds -- )
: DELAY BEGIN 1 - DUP 0 = UNTIL DROP ;

: SET_UP DESKTOP MAZE  LOGO THE_MAZE FOOTER ;


: RESET_GAME BUTTON_RESET GPIO_MASK GPLEV0 @ AND 0 <> IF SET_UP 100 135 FIND_ADDRESS START_POINT ! RESET WRITE_START THEN ;

: WAIT_RESET BUTTON_RESET GPIO_MASK BEGIN DUP GPLEV0 @ AND 0 <> UNTIL DROP RESET_GAME ;

\ parole per verificare se si è arrivati all'uscita del labirinto

: AUX DUP START_POINT @ = IF STOP_CHECK @ START_CHECK ! DROP RESET OK WAIT_RESET ELSE START_CHECK ! THEN ;

\ trovo il range di indirizzi che sono considerati uscita dal labirinto
: BEGIN_CHECK 2EC 12C FIND_ADDRESS START_CHECK ! 2EC 14B FIND_ADDRESS STOP_CHECK ! ;

: WIN  BEGIN_CHECK BEGIN START_CHECK @ 4 WIDTH * + AUX START_CHECK @ STOP_CHECK @ = UNTIL ;


\ implementiamo la logica del labirinto: non si può andare contro le pareti, 
\ ovvero nei pixel che già sono bianchi

\ (color -- )
: VERIFY_R START_POINT @ 4 + DUP WHITE SWAP @ <> IF DUP START_POINT ! ! WIN ELSE 2DROP RESET FAIL 10000 DELAY RESET GO THEN ;
 
: VERIFY_L START_POINT @ 4 - DUP WHITE SWAP @ <> IF DUP START_POINT ! ! WIN ELSE 2DROP RESET FAIL 10000 DELAY RESET GO THEN ;
: VERIFY_U START_POINT @ 4 WIDTH * - DUP WHITE SWAP @ <> IF DUP START_POINT ! ! WIN ELSE 2DROP RESET FAIL 10000 DELAY RESET GO THEN ;
: VERIFY_D START_POINT @ 4 WIDTH * + DUP WHITE SWAP @ <> IF DUP START_POINT ! ! WIN ELSE 2DROP RESET FAIL 10000 DELAY RESET GO THEN ;

\ ( color button_GPIO -- ) : quando il bottone è premuto scrive il pixel a cui punta lo start_point dopo aver verificato che è una posizione ammissibile

\ : WRITE_RIGHT BUTTON_RIGHT SWAP BEGIN 2DUP VERIFY_R 1000 DELAY GPIO_MASK GPLEV0 @ AND 0 = UNTIL 2DROP ;
\ : WRITE_LEFT BUTTON_LEFT SWAP BEGIN 2DUP VERIFY_L  1000 DELAY GPIO_MASK GPLEV0 @ AND 0 = UNTIL 2DROP ;
\ : WRITE_DOWN BUTTON_DOWN SWAP BEGIN 2DUP VERIFY_D 1000 DELAY GPIO_MASK GPLEV0 @ AND 0 = UNTIL 2DROP ;
\ : WRITE_UP BUTTON_UP SWAP BEGIN 2DUP VERIFY_U 1000 DELAY GPIO_MASK GPLEV0 @ AND 0 = UNTIL 2DROP ;

: WRITE_RIGHT BUTTON_RIGHT BEGIN DUP GPIO_MASK GPLEV0 @ AND 0 <> WHILE SWAP DUP VERIFY_R 1000 DELAY SWAP REPEAT 2DROP ;
: WRITE_LEFT BUTTON_LEFT BEGIN DUP GPIO_MASK GPLEV0 @ AND 0 <> WHILE SWAP DUP VERIFY_L 1000 DELAY SWAP REPEAT 2DROP ;
: WRITE_DOWN BUTTON_DOWN BEGIN DUP GPIO_MASK GPLEV0 @ AND 0 <> WHILE SWAP DUP VERIFY_D 1000 DELAY SWAP REPEAT 2DROP ;
: WRITE_UP BUTTON_UP BEGIN DUP GPIO_MASK GPLEV0 @ AND 0 <> WHILE SWAP DUP VERIFY_U 1000 DELAY SWAP REPEAT 2DROP ;

: ITER DUP 2DUP WRITE_RIGHT WRITE_LEFT WRITE_UP WRITE_DOWN ;

: PLAY 100 135 FIND_ADDRESS START_POINT ! RESET WRITE_START BEGIN GREEN ITER RESET_GAME BUTTON_OFF GPIO_MASK GPLEV0 @ AND 0 <> UNTIL DESKTOP ;

SET_UP PLAY







